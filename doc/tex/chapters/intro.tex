\section{Introduction}

Today, the service-oriented architectural style is well understood and is commonly applied to build software systems, across many application domains. IT departments apply it to build corporate information systems, internet start-ups apply it to create on-line services with a global audience. The platforms that support the construction of service-oriented systems, such as Java EE or Microsoft .Net, are now well established. Object-relational mapping frameworks have become very popular and are extensively used. In this context, the design and the implementation of a new information-driven service is a well understood process. A lot of information and documented best practices exist on the topic.

After the initial development phase, however, the situation tends to become much more complex and far less understood. Once the service has been deployed and made available to users, new requirements emerge and drive the evolution of the service. Very often, addressing these requirements requires an extension or a modification of the domain model. New business objects are added, existing business objects are modified, relationships between business objects are altered. These changes materialize in modifications of the underlying database schema and in transformations of the existing data. In an environment, where the same data store is used by a growing collection of services, ensuring that schema and data modifications preserve the behavior of the entire system is not trivial. Furthermore, applying these modifications in a way that fits the operational constraints of the organization is also a challenge. Many software systems are now expected to be available on a continuous basis, with few or no maintenance windows. Upgrading services with minimal downtime is always a challenge, but when data transformations are associated with the upgrade, it becomes a very difficult problem. In addition, the information managed by the evolving system is always a key asset of the organization. Hence, preserving the consistency of this information is of prime importance. Because they may impact on this consistency, the data transformations that are associated with the service evolution have a high associated risk. They have thus to be managed systematically and carefully.

The objective of this article is to propose a framework for dealing with the evolution of data-driven online services. The framework consists of processes, work practices and tools that aim to facilitate the evolution of a service-oriented system, by encompassing the evolution of the underlying information store. The framework is the result from our own experience with the iterative implementation of a global internet service, offered in a ''Software as a Service`` mode. The service is characterized both by a rapid functional evolution and by stringent reliability and availability requirements. 

\subsection{Objectives}

The framework presented in this article is the result of our practical experience with the development and the operation of an internet service with a large and fairly complex underlying database. The pace of development for the service is very fast, with new requirements flowing in constantly. The operational constraints are high, in terms of availability, scalability, performance and security. For these reasons, we are faced with a number of issues when dealing with the evolution of the service. The framework brings answers to some of these issues. As such, it addresses the following key objectives.

\begin{description}
\item[Visibility] Our first objective was to get better visibility on the database evolution. Developers in our team have a shared ownership on the codebase and it is common for all of them to modify the classes that define the domain model. This is true for experienced developers, who are in a good position to assess the impact and the risk associated with the changes. But this is also true for junior developers, who might not always realize that changes in the domain model have an impact on the production database. For this reason, one of the early ideas was to put in mechanisms for tracking and monitoring changes made to the domain model classes. 

\item[Automation and continuous integration] Our second objective was to tightly integrate the database evolution process with the codebase evolution process. In particular, it was to ensure that whenever a developer does a modification in the codebase, he analyzes what modifications are required in the database and he writes the corresponding schema and data transformation scripts. These scripts are first-class citizens and are managed in the version control system. The definition of procedures and guidelines, to be followed by software developers, was seen as an important element to achieve the objective. But it was also foreseen that raising the awareness among the developers and instilling the discipline to write the database transformation scripts was going to be a key element as well.

\item [Correctness and business impact] Our third objective was to ensure the correctness of the database transformation operations. As already mentioned, information in the database is a high-value asset and any inconsistency introduced by a database transformation can have a damaging business impact. It was therefore expected that specific work practices should be defined to minimize the risk associated with the service evolution. Beyond the correctness of the data transformations, the execution of the data transformations can have a significant business impact, because of the service level agreements specified for the system. With many internet services, availability is expected to be continuous and any planned downtime should be as short as possible. For this reason, the time required to execute the transformation scripts needs to be carefully assessed and managed. This is particularly important, because the database underlying an internet service is often very large.

\end{description}


\subsection{Organization}

The framework is a formalization of the work practices, procedures and supporting tools that were introduced in the organization, in order to manage the database evolution process. In this article, our goal is both to describe the framework at a conceptual level and to explain how it has been applied in practice. The remaining sections are organized as follows:

\begin{itemize}
\item In Section 2, we review several approaches to database evolution that have been described in the literature. We look at very practical and pragmatic approaches, but also at more conceptual and theoretical approaches. Our work has been inspired by some of this related work. We consider that our main contributions have been firstly to formalize the developers activities related to database evolution, and secondly to evaluate the proposed practices in a real-word environment.

\item In Section 3, we describe the framework itself. We first look at the different actors involved in the evolution process, such as the developers and the database administrators. We describe their main concerns and needs. We then describe the database evolution process and explain how it relates to the continuous software development process. This leads us to the description of a core activity in the framework, which is the \emph{migration} from one version of the service to another. Based on this, we describe what tasks need to be done on a continuous basis to ensure the success of every migration. We show how simple tooling can make these tasks easier and give visibility on the process. Finally, we describe some of the issues related to testing and validation. We are continuously extending and refining our framework, taking into account the feedback provided by every migration. Testing is clearly an important area that we plan to explore further in the future.

\item In Section 4, we look at the database evolution process from a risk assessment point of view. We provide a list of transformation operations, which are the results of common modifications made on the domain model. We assess both the \emph{risk} and the \emph{complexity} associated with the transformation. We also provide examples to illustrate what we mean by \emph{complexity}.

\item In Section 5, we consider a case study with two objectives. Firstly, we use it to present very practical aspects of the framework. Secondly, we use it to provide evaluation results. The framework, as a set of work practices and supporting tools, is the result of our ongoing work at Lotaris (as such, it is continuously refined and extended). By applying the principles in a real team, on a real service and with real operational constraints, we have been able to identity a set of challenges and pitfalls. We explain how we have been able to address some of them, and how we plan to address the others in the future.

\end{itemize}



Before presenting our Database Evolution Framework, we have a look at what is done elsewhere. We are exploring the tools, the processes and the best practices. Some papers will be described deeper than other in regards of their interests in our approach. After that, we present the framework we have imagined based on our readings and particularly our experience in database evolution management. We want to present how we have used our framework in a real case and for that we will offer you a study case. Finally, we go through what is missing in our framework and what we want to do in the future to improve our methodology and our tools.
